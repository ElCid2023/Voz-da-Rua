===============================================================================
                        PAINTBALL ARENA - GUIA COMPLETO DE DESENVOLVIMENTO
                                    FPS Mobile para PlayStore
===============================================================================

ÃNDICE:
1. CONCEITO E DESIGN DO JOGO
2. ESPECIFICAÃ‡Ã•ES TÃ‰CNICAS
3. INSTALAÃ‡ÃƒO E CONFIGURAÃ‡ÃƒO UNITY
4. ARQUITETURA DO PROJETO
5. SCRIPTS PRINCIPAIS
6. SISTEMA DE MONETIZAÃ‡ÃƒO
7. ROADMAP DE DESENVOLVIMENTO
8. PRÃ“XIMOS PASSOS

===============================================================================
1. CONCEITO E DESIGN DO JOGO
===============================================================================

NOME: Paintball Arena
GÃŠNERO: FPS Casual/Esportivo
PLATAFORMA: Android (PlayStore)
PÃšBLICO: 10+ anos (famÃ­lia-friendly)
SESSÃƒO: 3-8 minutos por partida

CONCEITO PRINCIPAL:
"O primeiro FPS verdadeiramente famÃ­lia-friendly"
- CompetiÃ§Ã£o esportiva real de paintball
- Zero violÃªncia, 100% diversÃ£o
- Foco em habilidade e estratÃ©gia
- Visual colorido e alegre

DIFERENCIAIS COMPETITIVOS:
1. Ãšnico FPS famÃ­lia-friendly no mercado
2. Tema esportivo real (paintball existe)
3. Zero violÃªncia - aprovaÃ§Ã£o parental
4. Visual Ãºnico e colorido
5. MecÃ¢nicas inovadoras (sistema de tinta)

MECÃ‚NICAS CORE:

Sistema de Tiro:
- Marcadores de paintball realistas
- TrajetÃ³ria parabÃ³lica (nÃ£o linear)
- Tinta splatter visual em superfÃ­cies
- Recarga manual de cÃ¡psulas
- Mira com mira laser

Sistema de EliminaÃ§Ã£o:
- Hit = Eliminado temporariamente
- Respawn apÃ³s 15 segundos
- Ãrea de respawn protegida
- Indicador visual de quem foi eliminado

Sistema de Tinta:
- 6 cores por time (vermelho vs azul base)
- Tintas especiais (neon, brilhante, metÃ¡lica)
- MarcaÃ§Ã£o territorial - tinta marca o mapa
- Limpeza automÃ¡tica entre rounds

MODOS DE JOGO:

1. Team Elimination (5v5)
- Eliminar todo time adversÃ¡rio
- 3 rounds, melhor de 3
- DuraÃ§Ã£o: 2-3 minutos por round

2. Capture the Flag
- Capturar bandeira inimiga
- Levar para base prÃ³pria
- DuraÃ§Ã£o: 5 minutos

3. King of the Hill
- Controlar Ã¡rea central
- Primeiro a 100 pontos
- DuraÃ§Ã£o: 4-6 minutos

4. Paint the Map
- Cobrir mais territÃ³rio com sua cor
- Medido por % do mapa pintado
- DuraÃ§Ã£o: 6 minutos

MAPAS/ARENAS:

Arena Floresta:
- Tema: Mata densa com obstÃ¡culos naturais
- Elementos: Ãrvores, pedras, riachos
- EstratÃ©gia: Emboscadas e flanqueamento

Arena Urbana:
- Tema: Cidade abandonada
- Elementos: Carros, containers, prÃ©dios baixos
- EstratÃ©gia: Combate vertical

Arena Deserto:
- Tema: Base militar no deserto
- Elementos: Bunkers, torres, veÃ­culos
- EstratÃ©gia: Longas distÃ¢ncias

Arena Neon (Premium):
- Tema: Cyberpunk com luzes neon
- Elementos: Plataformas flutuantes
- EstratÃ©gia: Movimento 3D

CUSTOMIZAÃ‡ÃƒO:

Marcadores (Armas):
- BÃ¡sico: Marcador padrÃ£o
- Sniper: Longo alcance, recarga lenta
- AutomÃ¡tico: Rajada rÃ¡pida, baixa precisÃ£o
- Shotgun: MÃºltiplos projÃ©teis, curto alcance
- Premium: Designs Ãºnicos, efeitos especiais

Equipamentos:
- MÃ¡scaras: 20+ designs diferentes
- Uniformes: Camuflagens, cores, padrÃµes
- Luvas: Diferentes estilos
- Botas: Velocidade vs proteÃ§Ã£o

Tintas Especiais:
- Neon: Brilha no escuro
- MetÃ¡lica: Efeito cromado
- Arco-Ã­ris: Muda de cor
- Explosiva: Ãrea de efeito maior

===============================================================================
2. ESPECIFICAÃ‡Ã•ES TÃ‰CNICAS
===============================================================================

ENGINE RECOMENDADA:
- Unity 3D (melhor para mobile FPS)
- Multiplayer: Photon PUN2
- Analytics: Unity Analytics + Firebase

VERSÃƒO UNITY:
- Unity 2022.3.21f1 LTS (Long Term Support)
- Melhor performance para mobile
- Compatibilidade com Android mais recentes
- Photon PUN2 funciona perfeitamente
- PlayStore aceita sem problemas

REQUISITOS MÃNIMOS:
- Android 7.0+
- 2GB RAM
- 1GB armazenamento
- OpenGL ES 3.0

CONTROLES MOBILE:
- Joystick virtual (movimento)
- Touch para mirar (giroscÃ³pio opcional)
- BotÃ£o de tiro grande e responsivo
- Gestos para aÃ§Ãµes especiais

DIREÃ‡ÃƒO VISUAL:
- Low-poly colorido (otimizado para mobile)
- Paleta vibrante mas nÃ£o agressiva
- AnimaÃ§Ãµes fluidas e responsivas
- UI limpa e intuitiva

EFEITOS ESPECIAIS:
- Splatter de tinta realista
- PartÃ­culas coloridas nos impactos
- Trails de projÃ©til visÃ­veis
- Feedback visual forte

===============================================================================
3. INSTALAÃ‡ÃƒO E CONFIGURAÃ‡ÃƒO UNITY
===============================================================================

DOWNLOAD E VERSÃƒO:

VersÃ£o Recomendada: Unity 2022.3.21f1 LTS

Links Diretos:
- Unity Hub: https://unity.com/download
- Windows: https://download.unity3d.com/download_unity/bf09ca542b87/Windows64EditorInstaller/UnitySetup64-2022.3.21f1.exe
- Mac: https://download.unity3d.com/download_unity/bf09ca542b87/MacEditorInstaller/Unity-2022.3.21f1.pkg
- Archive: https://unity.com/releases/editor/archive

MÃ³dulos Android NecessÃ¡rios:
âœ… Android Build Support
âœ… Android SDK & NDK Tools
âœ… OpenJDK
âœ… Visual Studio (Windows)

Tamanho do Download:
- Unity Editor: ~2.5GB
- Android Modules: ~1.5GB
- Total: ~4GB

CONFIGURAÃ‡ÃƒO PASSO A PASSO:

PASSO 1: Criar Projeto
Unity Hub â†’ Projects â†’ New Project
Template: 3D (URP)
Project Name: PaintballArena
Location: C:/GameDev/
Unity Version: 2022.3.21f1

PASSO 2: Configurar para Mobile
File â†’ Build Settings
Platform: Android
âœ… Switch Platform

Player Settings:
â€¢ Company Name: SeuNome
â€¢ Product Name: Paintball Arena
â€¢ Package Name: com.seunome.paintball
â€¢ Minimum API Level: 24 (Android 7.0)
â€¢ Target API Level: 33

PASSO 3: Instalar Photon PUN2
Window â†’ Package Manager
My Registries â†’ PUN 2 - FREE
âœ… Import

Ou Asset Store:
â€¢ Procure "PUN2 FREE"
â€¢ Download + Import

===============================================================================
4. ARQUITETURA DO PROJETO
===============================================================================

ESTRUTURA DE PASTAS:

ğŸ“ PaintballArena/
â”œâ”€â”€ ğŸ“ Assets/
â”‚   â”œâ”€â”€ ğŸ“ Scripts/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ Player/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ Weapons/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ GameModes/
â”‚   â”‚   â””â”€â”€ ğŸ“ UI/
â”‚   â”œâ”€â”€ ğŸ“ Prefabs/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ Player/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ Weapons/
â”‚   â”‚   â””â”€â”€ ğŸ“ Environment/
â”‚   â”œâ”€â”€ ğŸ“ Materials/
â”‚   â”œâ”€â”€ ğŸ“ Textures/
â”‚   â”œâ”€â”€ ğŸ“ Models/
â”‚   â””â”€â”€ ğŸ“ Scenes/
â”‚       â”œâ”€â”€ MainMenu.unity
â”‚       â”œâ”€â”€ GameArena.unity
â”‚       â””â”€â”€ TestScene.unity

ARQUITETURA DO JOGO:

GameManager â—„â”€â”€â–º PlayerManager â—„â”€â”€â–º UIManager
â”‚                â”‚                   â”‚
â”‚ â€¢ Game Mode    â”‚ â€¢ Movement        â”‚ â€¢ HUD
â”‚ â€¢ Score        â”‚ â€¢ Health          â”‚ â€¢ Menus
â”‚ â€¢ Timer        â”‚ â€¢ Weapons         â”‚ â€¢ Settings
â”‚                â”‚                   â”‚
â–¼                â–¼                   â–¼
NetworkManager   WeaponSystem        AudioManager
â”‚                â”‚                   â”‚
â”‚ â€¢ Photon       â”‚ â€¢ Shooting        â”‚ â€¢ SFX
â”‚ â€¢ Sync         â”‚ â€¢ Paint           â”‚ â€¢ Music
â”‚ â€¢ Rooms        â”‚ â€¢ Effects         â”‚ â€¢ Voice

SISTEMA DE MOVIMENTO DO PLAYER:

INPUT SYSTEM â†’ MOVEMENT LOGIC
Touch Joystick â†’ Transform Position
Camera Look â†’ Rigidbody Velocity

FEATURES:
â€¢ Mobile joystick
â€¢ Touch camera rotation
â€¢ Jump mechanics
â€¢ Crouch system

SISTEMA DE ARMAS:

AIM â†’ SHOOT â†’ IMPACT
â”‚      â”‚       â”‚
â”‚ â€¢ Crosshair  â”‚ â€¢ Projectile  â”‚ â€¢ Paint
â”‚ â€¢ Laser      â”‚ â€¢ Trajectory  â”‚ â€¢ Splatter
â”‚ â€¢ Zoom       â”‚ â€¢ Sound       â”‚ â€¢ Damage

PAINT PROJECTILE PHYSICS:
Start â— â†’ Gravity â†’ â— Impact â†’ SPLAT!

SISTEMA DE TINTA:

PAINT IMPACT SEQUENCE:
1. COLLISION â†’ 2. SPLATTER â†’ 3. MARK
Projectile Hits â†’ Particle Explosion â†’ Decal On Surface

VISUAL EFFECTS:
â— Paintball â†’ ğŸ’¥ Splash â†’ ğŸ¨ Paint Mark

PAINT COLORS:
ğŸ”´ Red Team    ğŸ”µ Blue Team   â­ Special
ğŸŸ¡ Yellow      ğŸŸ¢ Green       âœ¨ Neon
ğŸŸ  Orange      ğŸŸ£ Purple      ğŸŒˆ Rainbow

DESIGN DO MAPA:

FOREST ARENA (Top View):
ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²
ğŸŒ²  ğŸ”´ SPAWN     ğŸ FLAG      ğŸ”µ SPAWN  ğŸŒ²
ğŸŒ²     â”‚           â”‚           â”‚       ğŸŒ²
ğŸŒ²     â–¼           â–¼           â–¼       ğŸŒ²
ğŸŒ²  â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”     ğŸŒ²
ğŸŒ²  â”‚COVERâ”‚    â”‚TOWERâ”‚    â”‚COVERâ”‚     ğŸŒ²
ğŸŒ²  â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”˜     ğŸŒ²
ğŸŒ²     ğŸª¨         ğŸŒŠ         ğŸª¨       ğŸŒ²
ğŸŒ²   ROCKS      RIVER      ROCKS      ğŸŒ²
ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²ğŸŒ²

ELEMENTS:
ğŸŒ² Trees (Cover)    ğŸª¨ Rocks (Cover)
ğŸŒŠ River (Obstacle) ğŸ Objective
ğŸ”´ğŸ”µ Team Spawns    ğŸ—¼ Watchtower

UI MOBILE LAYOUT:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  [â¤ï¸ 100]  [â±ï¸ 2:30]  [ğŸ¯ 5 KILLS]  [âš™ï¸]        â”‚
â”‚                                                     â”‚
â”‚                GAME VIEW                           â”‚
â”‚                    â”Œâ”€â”€â”€â”                          â”‚
â”‚                    â”‚ + â”‚ â† Crosshair              â”‚
â”‚                    â””â”€â”€â”€â”˜                          â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”                              â”Œâ”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  ğŸ•¹ï¸  â”‚                              â”‚ ğŸ”«  â”‚     â”‚
â”‚  â”‚MOVE â”‚                              â”‚SHOOTâ”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”˜                              â””â”€â”€â”€â”€â”€â”˜     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”                     â”‚
â”‚     â”‚JUMP â”‚  â”‚CROUCHâ”‚ â”‚RELOADâ”‚                     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

===============================================================================
5. SISTEMA DE MONETIZAÃ‡ÃƒO
===============================================================================

MODELO FREEMIUM:
- Jogo base: Gratuito
- AnÃºncios: Entre partidas (opcional)
- Compras: Equipamentos premium

MOEDAS DO JOGO:
- Paint Coins: Ganhas jogando
- Premium Gems: Compradas com dinheiro

PACOTES DE COMPRA:
- Starter Pack: $2.99 (marcador + mÃ¡scara)
- Pro Player: $9.99 (equipamento completo)
- Arena Master: $19.99 (tudo + tintas especiais)

BATTLE PASS SEMANAL:
- Gratuito: Recompensas bÃ¡sicas
- Premium ($4.99): Equipamentos exclusivos

MONETIZATION FLOW:

FREE PLAYER JOURNEY:
Download â†’ Play â†’ Earn Coins â†’ Buy Items â†’ Enjoy

PREMIUM PLAYER JOURNEY:
Download â†’ Buy Pack â†’ Premium Items â†’ VIP Status

REVENUE STREAMS:
ğŸ’° Equipment Packs
ğŸ“º Rewarded Video Ads
â­ Battle Pass ($4.99)
ğŸ’ Premium Currency
ğŸ¨ Special Paint Colors

===============================================================================
6. ROADMAP DE DESENVOLVIMENTO
===============================================================================

FASE 1 (MVP - 3 meses):
- 1 mapa bÃ¡sico
- 1 modo de jogo (Team Elimination)
- Marcador bÃ¡sico
- CustomizaÃ§Ã£o simples
- Multiplayer local

FASE 2 (Beta - 2 meses):
- 3 mapas
- 2 modos de jogo
- Sistema de progressÃ£o
- MonetizaÃ§Ã£o bÃ¡sica
- Multiplayer online

FASE 3 (Launch - 1 mÃªs):
- 4 mapas
- 4 modos de jogo
- Sistema completo de customizaÃ§Ã£o
- Battle pass
- Marketing e ASO

DEVELOPMENT ROADMAP DETALHADO:

WEEK 1-2: SETUP & BASIC MOVEMENT
âœ… Unity project setup
âœ… Player controller
âœ… Mobile controls
âœ… Basic arena

WEEK 3-4: WEAPON SYSTEM
ğŸ”« Paintball gun mechanics
ğŸ¨ Paint projectile physics
ğŸ’¥ Impact effects
ğŸ¯ Aiming system

WEEK 5-6: MULTIPLAYER
ğŸŒ Photon PUN2 integration
ğŸ‘¥ Room system
ğŸ”„ Player synchronization
ğŸ“¡ Network optimization

WEEK 7-8: GAME MODES
âš”ï¸ Team Elimination
ğŸš© Capture the Flag
ğŸ¨ Paint the Map
ğŸ† Scoring system

WEEK 9-10: UI & POLISH
ğŸ“± Mobile UI
ğŸµ Audio system
âœ¨ Visual effects
ğŸ› Bug fixes

WEEK 11-12: MONETIZATION & LAUNCH
ğŸ’° In-app purchases
ğŸ“Š Analytics
ğŸš€ PlayStore preparation
ğŸ“ˆ Marketing materials

===============================================================================
7. PRÃ“XIMOS PASSOS
===============================================================================

CHECKLIST DE INSTALAÃ‡ÃƒO:
â–¡ 1. Baixar Unity Hub
â–¡ 2. Instalar Unity Hub
â–¡ 3. Criar conta Unity (se nÃ£o tiver)
â–¡ 4. Instalar Unity 2022.3.21f1
â–¡ 5. Adicionar mÃ³dulos Android
â–¡ 6. Configurar Android SDK
â–¡ 7. Testar criaÃ§Ã£o de projeto

QUANDO TERMINAR A INSTALAÃ‡ÃƒO:
1. âœ… Criar o projeto Paintball Arena
2. âœ… Configurar para Android
3. âœ… Instalar Photon PUN2
4. âœ… Importar os scripts principais

SCRIPTS PRINCIPAIS A SEREM CRIADOS:
1. ğŸ® PlayerController.cs - Movimento e controles
2. ğŸ”« PaintballGun.cs - Sistema de armas
3. ğŸ¨ PaintballProjectile.cs - ProjÃ©teis e fÃ­sica
4. ğŸ’¥ PaintSplatter.cs - Sistema de manchas
5. ğŸ¯ GameManager.cs - Gerencia modos de jogo
6. ğŸŒ NetworkManager.cs - Multiplayer com Photon
7. ğŸ“± MobileUI.cs - Interface mobile
8. ğŸ† ScoreManager.cs - Sistema de pontuaÃ§Ã£o

TUTORIAIS DISPONÃVEIS:
1. ğŸ”« Sistema de Armas Detalhado
2. ğŸŒ ConfiguraÃ§Ã£o Multiplayer
3. ğŸ¨ Sistema de Efeitos Visuais
4. ğŸ“± OtimizaÃ§Ã£o Mobile
5. ğŸ’° ImplementaÃ§Ã£o de MonetizaÃ§Ã£o

===============================================================================
8. SCRIPTS PRINCIPAIS - CÃ“DIGO COMPLETO
===============================================================================

SCRIPT 1: PlayerController.cs
------------------------------

using UnityEngine;
using Photon.Pun;

public class PlayerController : MonoBehaviourPunPV, IPunObservable
{
    [Header("Movement Settings")]
    public float moveSpeed = 5f;
    public float jumpForce = 8f;
    public float mouseSensitivity = 2f;
    public float crouchSpeed = 2f;

    [Header("Components")]
    public Camera playerCamera;
    public Rigidbody rb;
    public CapsuleCollider playerCollider;
    public Transform cameraHolder;

    [Header("Mobile Controls")]
    public FixedJoystick moveJoystick;
    public FixedButton jumpButton;
    public FixedButton crouchButton;
    public FixedButton shootButton;

    [Header("Ground Check")]
    public Transform groundCheck;
    public float groundDistance = 0.4f;
    public LayerMask groundMask;

    // Private variables
    private float xRotation = 0f;
    private bool isGrounded;
    private bool isCrouching = false;
    private float originalHeight;
    private Vector3 originalCameraPos;
    private Vector3 networkPosition;
    private Quaternion networkRotation;

    void Start()
    {
        // Store original values
        originalHeight = playerCollider.height;
        originalCameraPos = cameraHolder.localPosition;

        if (photonView.IsMine)
        {
            // Enable camera for local player
            playerCamera.enabled = true;

            // Setup mobile UI
            SetupMobileControls();
        }
        else
        {
            // Disable camera for remote players
            playerCamera.enabled = false;

            // Disable mobile controls for remote players
            if (moveJoystick) moveJoystick.gameObject.SetActive(false);
        }

        // Set network position
        networkPosition = transform.position;
        networkRotation = transform.rotation;
    }

    void Update()
    {
        if (photonView.IsMine)
        {
            HandleInput();
            HandleMovement();
            HandleCameraRotation();
            HandleJump();
            HandleCrouch();
        }
        else
        {
            // Smooth network position for remote players
            transform.position = Vector3.Lerp(transform.position, networkPosition, Time.deltaTime * 10f);
            transform.rotation = Quaternion.Lerp(transform.rotation, networkRotation, Time.deltaTime * 10f);
        }

        CheckGrounded();
    }

    void SetupMobileControls()
    {
        // Find mobile controls in scene
        if (!moveJoystick)
            moveJoystick = FindObjectOfType<FixedJoystick>();

        if (!jumpButton)
            jumpButton = GameObject.Find("JumpButton")?.GetComponent<FixedButton>();

        if (!crouchButton)
            crouchButton = GameObject.Find("CrouchButton")?.GetComponent<FixedButton>();

        if (!shootButton)
            shootButton = GameObject.Find("ShootButton")?.GetComponent<FixedButton>();
    }

    void HandleInput()
    {
        // Mobile input
        if (Application.platform == RuntimePlatform.Android)
        {
            // Handle touch input for camera rotation
            HandleTouchInput();
        }
        else
        {
            // PC input for testing
            HandlePCInput();
        }
    }

    void HandleTouchInput()
    {
        // Camera rotation with touch
        if (Input.touchCount > 0)
        {
            Touch touch = Input.GetTouch(0);

            // Only rotate camera if touch is not on UI
            if (!IsPointerOverUIObject())
            {
                if (touch.phase == TouchPhase.Moved)
                {
                    float touchX = touch.deltaPosition.x * mouseSensitivity * 0.01f;
                    float touchY = touch.deltaPosition.y * mouseSensitivity * 0.01f;

                    RotateCamera(touchX, touchY);
                }
            }
        }
    }

    void HandlePCInput()
    {
        float mouseX = Input.GetAxis("Mouse X") * mouseSensitivity;
        float mouseY = Input.GetAxis("Mouse Y") * mouseSensitivity;

        RotateCamera(mouseX, mouseY);
    }

    void RotateCamera(float mouseX, float mouseY)
    {
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -90f, 90f);

        cameraHolder.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
        transform.Rotate(Vector3.up * mouseX);
    }

    void HandleMovement()
    {
        float horizontal = 0f;
        float vertical = 0f;

        // Get input based on platform
        if (Application.platform == RuntimePlatform.Android && moveJoystick)
        {
            horizontal = moveJoystick.Horizontal;
            vertical = moveJoystick.Vertical;
        }
        else
        {
            horizontal = Input.GetAxis("Horizontal");
            vertical = Input.GetAxis("Vertical");
        }

        // Calculate movement direction
        Vector3 direction = transform.right * horizontal + transform.forward * vertical;
        direction.Normalize();

        // Apply speed modifier
        float currentSpeed = isCrouching ? crouchSpeed : moveSpeed;

        // Move the player
        Vector3 moveVelocity = direction * currentSpeed;
        rb.velocity = new Vector3(moveVelocity.x, rb.velocity.y, moveVelocity.z);
    }

    void HandleJump()
    {
        bool jumpInput = false;

        if (Application.platform == RuntimePlatform.Android && jumpButton)
        {
            jumpInput = jumpButton.Pressed;
        }
        else
        {
            jumpInput = Input.GetButtonDown("Jump");
        }

        if (jumpInput && isGrounded && !isCrouching)
        {
            rb.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
        }
    }

    void HandleCrouch()
    {
        bool crouchInput = false;

        if (Application.platform == RuntimePlatform.Android && crouchButton)
        {
            crouchInput = crouchButton.Pressed;
        }
        else
        {
            crouchInput = Input.GetKey(KeyCode.LeftControl);
        }

        if (crouchInput && !isCrouching)
        {
            StartCrouch();
        }
        else if (!crouchInput && isCrouching)
        {
            StopCrouch();
        }
    }

    void StartCrouch()
    {
        isCrouching = true;
        playerCollider.height = originalHeight * 0.5f;
        cameraHolder.localPosition = new Vector3(originalCameraPos.x, originalCameraPos.y * 0.5f, originalCameraPos.z);
    }

    void StopCrouch()
    {
        isCrouching = false;
        playerCollider.height = originalHeight;
        cameraHolder.localPosition = originalCameraPos;
    }

    void CheckGrounded()
    {
        isGrounded = Physics.CheckSphere(groundCheck.position, groundDistance, groundMask);
    }

    bool IsPointerOverUIObject()
    {
        if (Application.platform == RuntimePlatform.Android)
        {
            if (Input.touchCount > 0)
            {
                return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(Input.GetTouch(0).fingerId);
            }
        }
        return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();
    }

    // Network synchronization
    public void OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)
    {
        if (stream.IsWriting)
        {
            // Send position and rotation
            stream.SendNext(transform.position);
            stream.SendNext(transform.rotation);
            stream.SendNext(cameraHolder.rotation);
        }
        else
        {
            // Receive position and rotation
            networkPosition = (Vector3)stream.ReceiveNext();
            networkRotation = (Quaternion)stream.ReceiveNext();
            cameraHolder.rotation = (Quaternion)stream.ReceiveNext();
        }
    }

    void OnDrawGizmosSelected()
    {
        if (groundCheck)
        {
            Gizmos.color = isGrounded ? Color.green : Color.red;
            Gizmos.DrawWireSphere(groundCheck.position, groundDistance);
        }
    }
}

SCRIPT 2: PaintballGun.cs
--------------------------

using UnityEngine;
using Photon.Pun;

public class PaintballGun : MonoBehaviourPunPV
{
    [Header("Gun Settings")]
    public float fireRate = 3f;
    public float range = 100f;
    public float projectileSpeed = 20f;
    public int maxAmmo = 30;
    public float reloadTime = 2f;

    [Header("Components")]
    public Transform firePoint;
    public GameObject paintballPrefab;
    public ParticleSystem muzzleFlash;
    public AudioSource audioSource;
    public AudioClip shootSound;
    public AudioClip reloadSound;

    [Header("UI References")]
    public TMPro.TextMeshProUGUI ammoText;
    public UnityEngine.UI.Button reloadButton;

    [Header("Mobile Controls")]
    public FixedButton shootButton;
    public FixedButton reloadButtonMobile;

    // Private variables
    private float nextTimeToFire = 0f;
    private int currentAmmo;
    private bool isReloading = false;
    private PlayerController playerController;

    void Start()
    {
        currentAmmo = maxAmmo;
        playerController = GetComponent<PlayerController>();

        if (photonView.IsMine)
        {
            UpdateAmmoUI();
            SetupMobileControls();
        }
        else
        {
            // Disable shooting for remote players
            enabled = false;
        }
    }

    void Update()
    {
        if (!photonView.IsMine) return;

        HandleShooting();
        HandleReload();
    }

    void SetupMobileControls()
    {
        if (!shootButton)
            shootButton = GameObject.Find("ShootButton")?.GetComponent<FixedButton>();

        if (!reloadButtonMobile)
            reloadButtonMobile = GameObject.Find("ReloadButton")?.GetComponent<FixedButton>();

        if (reloadButton)
            reloadButton.onClick.AddListener(StartReload);
    }

    void HandleShooting()
    {
        bool shootInput = false;

        if (Application.platform == RuntimePlatform.Android && shootButton)
        {
            shootInput = shootButton.Pressed;
        }
        else
        {
            shootInput = Input.GetButton("Fire1");
        }

        if (shootInput && Time.time >= nextTimeToFire && currentAmmo > 0 && !isReloading)
        {
            nextTimeToFire = Time.time + 1f / fireRate;
            Shoot();
        }
    }

    void HandleReload()
    {
        bool reloadInput = false;

        if (Application.platform == RuntimePlatform.Android && reloadButtonMobile)
        {
            reloadInput = reloadButtonMobile.Pressed;
        }
        else
        {
            reloadInput = Input.GetKeyDown(KeyCode.R);
        }

        if (reloadInput && currentAmmo < maxAmmo && !isReloading)
        {
            StartReload();
        }
    }

    void Shoot()
    {
        currentAmmo--;
        UpdateAmmoUI();

        // Create paintball projectile
        photonView.RPC("FirePaintball", RpcTarget.All, firePoint.position, firePoint.rotation);

        // Play effects locally
        if (muzzleFlash)
            muzzleFlash.Play();

        if (audioSource && shootSound)
            audioSource.PlayOneShot(shootSound);
    }

    [PunRPC]
    void FirePaintball(Vector3 position, Quaternion rotation)
    {
        if (paintballPrefab)
        {
            GameObject paintball = Instantiate(paintballPrefab, position, rotation);

            // Add velocity to paintball
            Rigidbody rb = paintball.GetComponent<Rigidbody>();
            if (rb)
            {
                rb.velocity = rotation * Vector3.forward * projectileSpeed;
            }

            // Set team color
            PaintballProjectile projectile = paintball.GetComponent<PaintballProjectile>();
            if (projectile && photonView.IsMine)
            {
                projectile.SetTeamColor(GetPlayerTeam());
                projectile.SetShooter(photonView.owner);
            }
        }
    }

    void StartReload()
    {
        if (isReloading || currentAmmo >= maxAmmo) return;

        isReloading = true;

        if (audioSource && reloadSound)
            audioSource.PlayOneShot(reloadSound);

        Invoke(nameof(FinishReload), reloadTime);
    }

    void FinishReload()
    {
        currentAmmo = maxAmmo;
        isReloading = false;
        UpdateAmmoUI();
    }

    void UpdateAmmoUI()
    {
        if (ammoText)
        {
            ammoText.text = $"{currentAmmo}/{maxAmmo}";

            if (isReloading)
                ammoText.text = "Reloading...";
        }
    }

    string GetPlayerTeam()
    {
        // Get team from custom properties
        if (PhotonNetwork.LocalPlayer.CustomProperties.TryGetValue("team", out object team))
        {
            return team.ToString();
        }
        return "red"; // Default team
    }
}

SCRIPT 3: PaintballProjectile.cs
--------------------------------

using UnityEngine;
using Photon.Pun;

public class PaintballProjectile : MonoBehaviourPunPV
{
    [Header("Projectile Settings")]
    public float lifetime = 5f;
    public float gravity = 9.81f;
    public LayerMask hitLayers = -1;

    [Header("Paint Settings")]
    public GameObject paintSplatterPrefab;
    public ParticleSystem impactParticles;
    public AudioClip impactSound;

    [Header("Team Colors")]
    public Material redTeamMaterial;
    public Material blueTeamMaterial;
    public Material[] specialMaterials;

    // Private variables
    private Rigidbody rb;
    private string teamColor = "red";
    private Photon.Realtime.Player shooter;
    private bool hasHit = false;

    void Start()
    {
        rb = GetComponent<Rigidbody>();

        // Apply gravity
        rb.useGravity = true;

        // Destroy after lifetime
        Destroy(gameObject, lifetime);

        // Set initial material
        SetTeamMaterial();
    }

    void Update()
    {
        // Add custom gravity for more realistic paintball physics
        rb.AddForce(Vector3.down * gravity, ForceMode.Acceleration);
    }

    public void SetTeamColor(string color)
    {
        teamColor = color;
        SetTeamMaterial();
    }

    public void SetShooter(Photon.Realtime.Player player)
    {
        shooter = player;
    }

    void SetTeamMaterial()
    {
        Renderer renderer = GetComponent<Renderer>();
        if (!renderer) return;

        switch (teamColor.ToLower())
        {
            case "red":
                if (redTeamMaterial)
                    renderer.material = redTeamMaterial;
                break;
            case "blue":
                if (blueTeamMaterial)
                    renderer.material = blueTeamMaterial;
                break;
            default:
                // Use special materials for premium colors
                if (specialMaterials.Length > 0)
                    renderer.material = specialMaterials[0];
                break;
        }
    }

    void OnCollisionEnter(Collision collision)
    {
        if (hasHit) return;
        hasHit = true;

        // Check if hit a player
        PlayerController hitPlayer = collision.gameObject.GetComponent<PlayerController>();
        if (hitPlayer && hitPlayer.photonView.owner != shooter)
        {
            // Hit enemy player
            HitPlayer(hitPlayer);
        }

        // Create paint splatter
        CreatePaintSplatter(collision);

        // Play impact effects
        PlayImpactEffects(collision.contacts[0].point);

        // Destroy projectile
        if (photonView.IsMine)
        {
            PhotonNetwork.Destroy(gameObject);
        }
    }

    void HitPlayer(PlayerController player)
    {
        if (!photonView.IsMine) return;

        // Send hit notification
        player.photonView.RPC("OnHitByPaintball", RpcTarget.All, shooter.NickName, teamColor);

        // Award points to shooter
        GameManager.Instance?.AddScore(shooter, 10);
    }

    void CreatePaintSplatter(Collision collision)
    {
        if (!paintSplatterPrefab) return;

        Vector3 hitPoint = collision.contacts[0].point;
        Vector3 hitNormal = collision.contacts[0].normal;

        // Create splatter decal
        GameObject splatter = Instantiate(paintSplatterPrefab, hitPoint, Quaternion.LookRotation(hitNormal));

        // Set splatter color
        PaintSplatter splatterComponent = splatter.GetComponent<PaintSplatter>();
        if (splatterComponent)
        {
            splatterComponent.SetColor(teamColor);
        }

        // Network sync the splatter
        if (photonView.IsMine)
        {
            photonView.RPC("SyncPaintSplatter", RpcTarget.Others, hitPoint, hitNormal, teamColor);
        }
    }

    [PunRPC]
    void SyncPaintSplatter(Vector3 position, Vector3 normal, string color)
    {
        if (paintSplatterPrefab)
        {
            GameObject splatter = Instantiate(paintSplatterPrefab, position, Quaternion.LookRotation(normal));
            PaintSplatter splatterComponent = splatter.GetComponent<PaintSplatter>();
            if (splatterComponent)
            {
                splatterComponent.SetColor(color);
            }
        }
    }

    void PlayImpactEffects(Vector3 position)
    {
        // Play particle effect
        if (impactParticles)
        {
            ParticleSystem particles = Instantiate(impactParticles, position, Quaternion.identity);

            // Set particle color based on team
            var main = particles.main;
            switch (teamColor.ToLower())
            {
                case "red":
                    main.startColor = Color.red;
                    break;
                case "blue":
                    main.startColor = Color.blue;
                    break;
                default:
                    main.startColor = Color.white;
                    break;
            }

            particles.Play();
            Destroy(particles.gameObject, 2f);
        }

        // Play sound effect
        if (impactSound)
        {
            AudioSource.PlayClipAtPoint(impactSound, position);
        }
    }
}

===============================================================================
                                    FIM DO GUIA
===============================================================================

Este documento contÃ©m todo o planejamento, estrutura e cÃ³digo principal para
desenvolver o Paintball Arena, um FPS famÃ­lia-friendly para mobile.

CONTEÃšDO INCLUÃDO:
âœ… Conceito completo do jogo
âœ… EspecificaÃ§Ãµes tÃ©cnicas
âœ… Guia de instalaÃ§Ã£o Unity
âœ… Arquitetura do projeto
âœ… Scripts principais (PlayerController, PaintballGun, PaintballProjectile)
âœ… Sistema de monetizaÃ§Ã£o
âœ… Roadmap de desenvolvimento
âœ… PrÃ³ximos passos

SCRIPTS ADICIONAIS DISPONÃVEIS:
- GameManager.cs (gerenciamento de jogo)
- NetworkManager.cs (multiplayer)
- PaintSplatter.cs (sistema de manchas)
- MobileUI.cs (interface mobile)
- ScoreManager.cs (pontuaÃ§Ã£o)

Para continuar o desenvolvimento:
1. Instalar Unity 2022.3.21f1 LTS
2. Configurar projeto para Android
3. Instalar Photon PUN2
4. Implementar scripts fornecidos
5. Testar e iterar
6. Publicar na PlayStore

Boa sorte no desenvolvimento! ğŸ®ğŸš€

Este documento contÃ©m todo o planejamento e estrutura para desenvolver o
Paintball Arena, um FPS famÃ­lia-friendly para mobile. 

Para continuar o desenvolvimento, siga a ordem:
1. Instalar Unity
2. Configurar projeto
3. Implementar scripts
4. Testar e iterar
5. Publicar na PlayStore

Boa sorte no desenvolvimento! ğŸ®ğŸš€
